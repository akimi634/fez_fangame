<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_block</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Códigos executados quando o bloco é iniciado

//Todo bloco tem uma altura, que é definida pela variável z:
z=0;

/*Todo bloco tem que ter texturas diferentes nas laterais. Algumas são de acordo com a situação, outras podem ser aleatórias.
A sprite de textura é sempre gerada da seguinte forma:
Imagem 0: lateral do bloco, com terminações na esquerda e na direita.
Imagem 1: lateral do bloco, com terminação na direita.
Imagem 2: lateral do bloco, com terminação na esquerda.
Imagens 3, 4, 5 e 6: lateral do bloco, sem terminações. Qualquer uma pode ser escolhida.
Imagem 7: topo e base do bloco. Pretendo fazer uma 8ª pra fazer a base...
VALE LEMBRAR QUE, pra corrigir o bug de texture clamping, as sprites no arquivo devem ser espelhadas (terminação na direta sendo na esquerda, por exemplo).*/

//No caso das laterais, podem ser escolhidas as imagens 3, 4, 5 e 6 aleatoriamente.
lado_dir=choose(3,4,5,6);
lado_cim=choose(3,4,5,6);
lado_esq=choose(3,4,5,6);
lado_bai=choose(3,4,5,6);

//No topo e na base, seta a imagem 7.
lado_topo=7;
lado_base=7;

//O alarme 0 vai calcular, no próximo frame, quem são os blocos vizinhos desse bloco,
//retirar as texturas que não precisarão ser utilizadas e atualizar as texturas que correspondem as terminações corretas.
//Isso é feito no próximo frame e não agora pois, pode ser que nesse exato momento que esse código estiver sendo executado,
//os blocos vizinhos ainda não tenham sido gerados. Se isso ocorrer, haverá problemas na computação desses resultados.
//Por isso que isso é executado no próximo frame, entendeu?
alarm[0]=1;

//E como esse aqui pertence ao bloco do editor, quando ele é criado, ele faz a computação
//acontecer também para os blocos que estão do lado dele.
with (instance_position(x+16,y,obj_editor_block)) { alarm[0]=1; }
with (instance_position(x,y-16,obj_editor_block)) { alarm[0]=1; }
with (instance_position(x-16,y,obj_editor_block)) { alarm[0]=1; }
with (instance_position(x,y+16,obj_editor_block)) { alarm[0]=1; }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Códigos para serem executados quando esse objeto for destruído:

//No caso, no editor, se bloco for destruído, ele tem que atualizar seus vizinhos, pra pegarem as texturas atualizadas.
with (instance_position(x+16,y,obj_editor_block)) { alarm[0]=1; }
with (instance_position(x,y-16,obj_editor_block)) { alarm[0]=1; }
with (instance_position(x-16,y,obj_editor_block)) { alarm[0]=1; }
with (instance_position(x,y+16,obj_editor_block)) { alarm[0]=1; }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código a ser executado 1 frame após a criação do bloco

//Esse código tá um pouco diferente do bloco do jogo porque andou dando uns bugs loucos, não sei o que houve. Precisei adaptá-lo para computar TODOS os blocos já construídos.
//Sei que isso, em fases maiores, vai levar um século pra processar em cada bloco, mas... Fazer o que...
//Se alguém tiver um código melhor, me avise!

//AAARRGH, ESSA COISA TÁ BUGADA. HALP ME PL0X11!1!

//Inicialmente, define que este bloco ainda não encontrou nenhum bloco vizinho em nenhum lado.
encontrou_dir=0;
encontrou_cim=0;
encontrou_esq=0;
encontrou_bai=0;

//Então, ele começa a computar os blocos vizinhos.
//Se a posição Z do bloco vizinho for a mesma do bloco atual, então significa que ele é realmente um vizinho, e seta a variável encontrou_xxx de acordo.
//Primeiro, o bloco na posição x+16 deste (direita).
with (obj_editor_block) {
    if (self.x==other.x+16)
    and (self.y==other.y)
    and (self.z==other.z) {
        other.encontrou_dir=1;
    }
}
//Depois, o bloco na posição y-16 deste (acima).
with (obj_editor_block) {
    if (self.x==other.x)
    and (self.y==other.y-16)
    and (self.z==other.z) {
        other.encontrou_cim=1;
    }
}
//Depois, o bloco na posição x-16 deste (esquerda).
with (obj_editor_block) {
    if (self.x==other.x-16)
    and (self.y==other.y)
    and (self.z==other.z) {
        other.encontrou_esq=1;
    }
}
//Depois, o bloco na posição y+16 deste (abaixo).
with (obj_editor_block) {
    if (self.x==other.x)
    and (self.y==other.y+16)
    and (self.z==other.z) {
        other.encontrou_bai=1;
    }
}
/*Vale lembrar que isso é como se fosse a planta baixa do mapa. Como o GameMaker não tem muitas funções de coordenadas em 3 dimensões exatas, tem que fazer
essa POGzinha ali em cima pra identificar se o bloco vizinho "realmente é vizinho", isto é, se a posição Z dele é a mesma da posição Z deste!*/

//Aqui, uma série de situações que podem ocorrer, e o bloco experimenta a que mais se adequa a ele.
//Caso ele encontre um bloco em um lado específico, ele desativa aquela textura (-1 = Sem textura)
//e se houver ou não mais blocos nas laterais, altera as outras texturas correspondentes
//(0 = Terminações nos dois lados; 1 = Terminação na esquerda; 2 = Terminação na direita).
//Vou fazer gráfico pra entender melhor essa parada aqui. X é quando tem bloco, e 0 é quando não tem.
//Caso 1:
//  0
// 0X0
//  0
//Aciona todas as texturas
if (encontrou_dir==0)
and (encontrou_cim==0)
and (encontrou_esq==0)
and (encontrou_bai==0) {
    lado_dir=0;
    lado_cim=0;
    lado_esq=0;
    lado_bai=0;
}
//Caso 2:
//  0
// 0XX
//  0
//Desativa a textura da direita
else if (encontrou_dir==1)
and (encontrou_cim==0)
and (encontrou_esq==0)
and (encontrou_bai==0) {
    lado_dir=-1;
    lado_cim=2;
    lado_esq=0;
    lado_bai=1;
}
//Caso 3:
//  X
// 0X0
//  0
//Desativa a textura de cima
else if (encontrou_dir==0)
and (encontrou_cim==1)
and (encontrou_esq==0)
and (encontrou_bai==0) {
    lado_dir=1;
    lado_cim=-1;
    lado_esq=2;
    lado_bai=0;
}
//Caso 4:
//  0
// XX0
//  0
//Desativa a textura da esquerda
else if (encontrou_dir==0)
and (encontrou_cim==0)
and (encontrou_esq==1)
and (encontrou_bai==0) {
    lado_dir=0;
    lado_cim=1;
    lado_esq=-1;
    lado_bai=2;
}
//Caso 5:
//  0
// 0X0
//  X
//Desativa a textura de baixo
else if (encontrou_dir==0)
and (encontrou_cim==0)
and (encontrou_esq==0)
and (encontrou_bai==1) {
    lado_dir=2;
    lado_cim=0;
    lado_esq=1;
    lado_bai=-1;
}
//Caso 6:
//  X
// 0XX
//  0
//Desativa a textura da direita e de cima
else if (encontrou_dir==1)
and (encontrou_cim==1)
and (encontrou_esq==0)
and (encontrou_bai==0) {
    lado_dir=-1;
    lado_cim=-1;
    lado_esq=2;
    lado_bai=1;
}
//Caso 7:
//  X
// XX0
//  0
//Desativa a textura da esquerda e de cima
else if (encontrou_dir==0)
and (encontrou_cim==1)
and (encontrou_esq==1)
and (encontrou_bai==0) {
    lado_dir=1;
    lado_cim=-1;
    lado_esq=-1;
    lado_bai=2;
}
//Caso 8:
//  0
// XX0
//  X
//Desativa a textura da esquerda e de baixo
else if (encontrou_dir==0)
and (encontrou_cim==0)
and (encontrou_esq==1)
and (encontrou_bai==1) {
    lado_dir=2;
    lado_cim=1;
    lado_esq=-1;
    lado_bai=-1;
}
//Caso 9:
//  0
// 0XX
//  X
//Desativa a textura da direita e de baixo
else if (encontrou_dir==1)
and (encontrou_cim==0)
and (encontrou_esq==0)
and (encontrou_bai==1) {
    lado_dir=-1;
    lado_cim=2;
    lado_esq=1;
    lado_bai=-1;
}
//Caso 10:
//  0
// XXX
//  0
//Desativa a textura da esquerda e da direita
else if (encontrou_dir==1)
and (encontrou_cim==0)
and (encontrou_esq==1)
and (encontrou_bai==0) {
    lado_dir=-1;
    lado_cim=choose(3,4,5,6);
    lado_esq=-1;
    lado_bai=choose(3,4,5,6);
}
//Caso 11:
//  X
// 0X0
//  X
//Desativa a textura de cima e de baixo
else if (encontrou_dir==0)
and (encontrou_cim==1)
and (encontrou_esq==0)
and (encontrou_bai==1) {
    lado_dir=choose(3,4,5,6);
    lado_cim=-1;
    lado_esq=choose(3,4,5,6);
    lado_bai=-1;
}
//Caso 12:
//  X
// XXX
//  0
//Habilita somente a textura de baixo
else if (encontrou_dir==1)
and (encontrou_cim==1)
and (encontrou_esq==1)
and (encontrou_bai==0) {
    lado_dir=-1;
    lado_cim=-1;
    lado_esq=-1;
    lado_bai=choose(3,4,5,6);
}
//Caso 13:
//  X
// XX0
//  X
//Habilita somente a textura da direita
else if (encontrou_dir==0)
and (encontrou_cim==1)
and (encontrou_esq==1)
and (encontrou_bai==1) {
    lado_dir=choose(3,4,5,6);
    lado_cim=-1;
    lado_esq=-1;
    lado_bai=-1;
}
//Caso 14:
//  0
// XXX
//  X
//Habilita somente a textura de cima
else if (encontrou_dir==1)
and (encontrou_cim==0)
and (encontrou_esq==1)
and (encontrou_bai==1) {
    lado_dir=-1;
    lado_cim=choose(3,4,5,6);
    lado_esq=-1;
    lado_bai=-1;
}
//Caso 15:
//  X
// 0XX
//  X
//Habilita somente a textura da esquerda
else if (encontrou_dir==1)
and (encontrou_cim==1)
and (encontrou_esq==0)
and (encontrou_bai==1) {
    lado_dir=-1;
    lado_cim=-1;
    lado_esq=choose(3,4,5,6);
    lado_bai=-1;
}
//Caso 16:
//  X
// XXX
//  X
//Desativa todas as texturas laterais
else if (encontrou_dir==1)
and (encontrou_cim==1)
and (encontrou_esq==1)
and (encontrou_bai==1) {
    lado_dir=-1;
    lado_cim=-1;
    lado_esq=-1;
    lado_bai=-1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código de desenho do bloco:

//Aqui, verifica se a textura é maior que -1 (isto é, ativada), e se a visualização da câmera (direcao_view)
//está em uma posição que a lateral deve ser desenhada!
//No meio, as cores são setadas em branco, cinza claro, cinza e cinza claro,
//para fazer o efeito de shading, como se a luz estivesse vinda de algum lugar.
//Diferente do bloco original no game, esses aqui tem todos os seus lados renderizados, por questões de compatibilidade...

//Cima:
draw_set_color(c_white);
if (lado_cim&gt;-1) { d3d_draw_wall(x+16,y,z+16,x,y,z,sprite_get_texture(spr_block,lado_cim),1,1); }

//Topo:
if (lado_topo&gt;-1) { d3d_draw_floor(x,y,z+16,x+16,y+16,z+16,sprite_get_texture(spr_block,lado_topo),1,1); }

//Direita:
draw_set_color(c_ltgray);
if (lado_dir&gt;-1) { d3d_draw_wall(x+16,y+16,z+16,x+16,y,z,sprite_get_texture(spr_block,lado_dir),1,1); }

//Baixo:
draw_set_color(c_gray);
if (lado_bai&gt;-1) { d3d_draw_wall(x,y+16,z+16,x+16,y+16,z,sprite_get_texture(spr_block,lado_bai),1,1); }

//Base:
if (lado_base&gt;-1) { d3d_draw_floor(x,y,z,x+16,y+16,z,sprite_get_texture(spr_block,lado_base),1,1); }

//Esquerda:
draw_set_color(c_ltgray);
if (lado_esq&gt;-1) { d3d_draw_wall(x,y,z+16,x,y+16,z,sprite_get_texture(spr_block,lado_esq),1,1); }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>8,8</point>
  </PhysicsShapePoints>
</object>
