<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_block</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>mask_block</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Códigos executados quando o bloco é iniciado

//Todo bloco tem uma altura, que é definida pela variável z:
z=0;

/*Todo bloco tem que ter texturas diferentes nas laterais. Algumas são de acordo com a situação, outras podem ser aleatórias.
A sprite de textura é sempre gerada da seguinte forma:
Imagem 0: lateral do bloco, com terminações na esquerda e na direita.
Imagem 1: lateral do bloco, com terminação na direita.
Imagem 2: lateral do bloco, com terminação na esquerda.
Imagens 3, 4, 5 e 6: lateral do bloco, sem terminações. Qualquer uma pode ser escolhida.
Imagem 7: topo e base do bloco. Pretendo fazer uma 8ª pra fazer a base...
VALE LEMBRAR QUE, pra corrigir o bug de texture clamping, as sprites no arquivo devem ser espelhadas (terminação na direta sendo na esquerda, por exemplo).*/

//No caso das laterais, podem ser escolhidas as imagens 3, 4, 5 e 6 aleatoriamente, de acordo com o nível correto.
//0 a 6 = Nível sem blocos verticais vizinhos
//7 a 13 = Nível com bloco vertical vizinho abaixo
//14 a 20 = Nível com bloco vertical vizinho acima
//21 a 27 = Nível com blocos verticais vizinhos
lado_dir=choose(3,4,5,6);
lado_cim=choose(3,4,5,6);
lado_esq=choose(3,4,5,6);
lado_bai=choose(3,4,5,6);

//No topo e na base, seta a imagem 28.
lado_topo=28;
lado_base=28;

//O alarme 0 vai calcular, no próximo frame, quem são os blocos vizinhos desse bloco,
//retirar as texturas que não precisarão ser utilizadas e atualizar as texturas que correspondem as terminações corretas.
//Isso é feito no próximo frame e não agora pois, pode ser que nesse exato momento que esse código estiver sendo executado,
//os blocos vizinhos ainda não tenham sido gerados. Se isso ocorrer, haverá problemas na computação desses resultados.
//Por isso que isso é executado no próximo frame, entendeu?
alarm[0]=1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código a ser executado 1 frame após a criação do bloco

//Inicialmente, pega-se as IDs dos blocos vizinhos.
bloco_dir=noone;
bloco_cim=noone;
bloco_esq=noone;
bloco_bai=noone;
bloco_topo=noone;
bloco_base=noone;
with (obj_block) {
    if (self.z==other.z) {
        if (self.x==other.x+16) and (self.y==other.y) {
            other.bloco_dir=self.id;
        }
        if (self.x==other.x) and (self.y==other.y-16) {
            other.bloco_cim=self.id;
        }
        if (self.x==other.x-16) and (self.y==other.y) {
            other.bloco_esq=self.id;
        }
        if (self.x==other.x) and (self.y==other.y+16) {
            other.bloco_bai=self.id;
        }
    }
    if (self.z==other.z+16) and (self.x==other.x) and (self.y==other.y) {
        other.bloco_topo=self.id;
    }
    if (self.z==other.z-16) and (self.x==other.x) and (self.y==other.y) {
        other.bloco_base=self.id;
    }
}

//Define que, este bloco ainda não encontrou nenhum bloco vizinho em nenhum lado.
encontrou_dir=0;
encontrou_cim=0;
encontrou_esq=0;
encontrou_bai=0;

//Então, ele começa a computar os blocos vizinhos.
//Se a posição Z do bloco vizinho for a mesma do bloco atual, então significa que ele é realmente um vizinho, e seta a variável encontrou_xxx de acordo.
//Primeiro, o bloco na posição x+16 deste (direita).
with (bloco_dir) {
    if (self.z==other.z) {
        other.encontrou_dir=1;
    }
}
//Depois, o bloco na posição y-16 deste (acima).
with (bloco_cim) {
    if (self.z==other.z) {
        other.encontrou_cim=1;
    }
}
//Depois, o bloco na posição x-16 deste (esquerda).
with (bloco_esq) {
    if (self.z==other.z) {
        other.encontrou_esq=1;
    }
}
//Depois, o bloco na posição y+16 deste (abaixo).
with (bloco_bai) {
    if (self.z==other.z) {
        other.encontrou_bai=1;
    }
}
/*Vale lembrar que isso é como se fosse a planta baixa do mapa. Como o GameMaker não tem muitas funções de coordenadas em 3 dimensões exatas, tem que fazer
essa POGzinha ali em cima pra identificar se o bloco vizinho "realmente é vizinho", isto é, se a posição Z dele é a mesma da posição Z deste!*/

//Aqui, uma série de situações que podem ocorrer, e o bloco experimenta a que mais se adequa a ele.
//Caso ele encontre um bloco em um lado específico, ele desativa aquela textura (-1 = Sem textura)
//e se houver ou não mais blocos nas laterais, altera as outras texturas correspondentes
//(0 = Terminações nos dois lados; 1 = Terminação na esquerda; 2 = Terminação na direita).
//Vou fazer gráfico pra entender melhor essa parada aqui. X é quando tem bloco, e 0 é quando não tem.
//Caso 1:
//  0
// 0X0
//  0
//Aciona todas as texturas
if (encontrou_dir==0)
and (encontrou_cim==0)
and (encontrou_esq==0)
and (encontrou_bai==0) {
    lado_dir=0;
    lado_cim=0;
    lado_esq=0;
    lado_bai=0;
}
//Caso 2:
//  0
// 0XX
//  0
//Desativa a textura da direita
else if (encontrou_dir==1)
and (encontrou_cim==0)
and (encontrou_esq==0)
and (encontrou_bai==0) {
    lado_dir=-1;
    lado_cim=2;
    lado_esq=0;
    lado_bai=1;
}
//Caso 3:
//  X
// 0X0
//  0
//Desativa a textura de cima
else if (encontrou_dir==0)
and (encontrou_cim==1)
and (encontrou_esq==0)
and (encontrou_bai==0) {
    lado_dir=1;
    lado_cim=-1;
    lado_esq=2;
    lado_bai=0;
}
//Caso 4:
//  0
// XX0
//  0
//Desativa a textura da esquerda
else if (encontrou_dir==0)
and (encontrou_cim==0)
and (encontrou_esq==1)
and (encontrou_bai==0) {
    lado_dir=0;
    lado_cim=1;
    lado_esq=-1;
    lado_bai=2;
}
//Caso 5:
//  0
// 0X0
//  X
//Desativa a textura de baixo
else if (encontrou_dir==0)
and (encontrou_cim==0)
and (encontrou_esq==0)
and (encontrou_bai==1) {
    lado_dir=2;
    lado_cim=0;
    lado_esq=1;
    lado_bai=-1;
}
//Caso 6:
//  X
// 0XX
//  0
//Desativa a textura da direita e de cima
else if (encontrou_dir==1)
and (encontrou_cim==1)
and (encontrou_esq==0)
and (encontrou_bai==0) {
    lado_dir=-1;
    lado_cim=-1;
    lado_esq=2;
    lado_bai=1;
}
//Caso 7:
//  X
// XX0
//  0
//Desativa a textura da esquerda e de cima
else if (encontrou_dir==0)
and (encontrou_cim==1)
and (encontrou_esq==1)
and (encontrou_bai==0) {
    lado_dir=1;
    lado_cim=-1;
    lado_esq=-1;
    lado_bai=2;
}
//Caso 8:
//  0
// XX0
//  X
//Desativa a textura da esquerda e de baixo
else if (encontrou_dir==0)
and (encontrou_cim==0)
and (encontrou_esq==1)
and (encontrou_bai==1) {
    lado_dir=2;
    lado_cim=1;
    lado_esq=-1;
    lado_bai=-1;
}
//Caso 9:
//  0
// 0XX
//  X
//Desativa a textura da direita e de baixo
else if (encontrou_dir==1)
and (encontrou_cim==0)
and (encontrou_esq==0)
and (encontrou_bai==1) {
    lado_dir=-1;
    lado_cim=2;
    lado_esq=1;
    lado_bai=-1;
}
//Caso 10:
//  0
// XXX
//  0
//Desativa a textura da esquerda e da direita
else if (encontrou_dir==1)
and (encontrou_cim==0)
and (encontrou_esq==1)
and (encontrou_bai==0) {
    lado_dir=-1;
    lado_cim=choose(3,4,5,6);
    lado_esq=-1;
    lado_bai=choose(3,4,5,6);
}
//Caso 11:
//  X
// 0X0
//  X
//Desativa a textura de cima e de baixo
else if (encontrou_dir==0)
and (encontrou_cim==1)
and (encontrou_esq==0)
and (encontrou_bai==1) {
    lado_dir=choose(3,4,5,6);
    lado_cim=-1;
    lado_esq=choose(3,4,5,6);
    lado_bai=-1;
}
//Caso 12:
//  X
// XXX
//  0
//Habilita somente a textura de baixo
else if (encontrou_dir==1)
and (encontrou_cim==1)
and (encontrou_esq==1)
and (encontrou_bai==0) {
    lado_dir=-1;
    lado_cim=-1;
    lado_esq=-1;
    lado_bai=choose(3,4,5,6);
}
//Caso 13:
//  X
// XX0
//  X
//Habilita somente a textura da direita
else if (encontrou_dir==0)
and (encontrou_cim==1)
and (encontrou_esq==1)
and (encontrou_bai==1) {
    lado_dir=choose(3,4,5,6);
    lado_cim=-1;
    lado_esq=-1;
    lado_bai=-1;
}
//Caso 14:
//  0
// XXX
//  X
//Habilita somente a textura de cima
else if (encontrou_dir==1)
and (encontrou_cim==0)
and (encontrou_esq==1)
and (encontrou_bai==1) {
    lado_dir=-1;
    lado_cim=choose(3,4,5,6);
    lado_esq=-1;
    lado_bai=-1;
}
//Caso 15:
//  X
// 0XX
//  X
//Habilita somente a textura da esquerda
else if (encontrou_dir==1)
and (encontrou_cim==1)
and (encontrou_esq==0)
and (encontrou_bai==1) {
    lado_dir=-1;
    lado_cim=-1;
    lado_esq=choose(3,4,5,6);
    lado_bai=-1;
}
//Caso 16:
//  X
// XXX
//  X
//Desativa todas as texturas laterais
else if (encontrou_dir==1)
and (encontrou_cim==1)
and (encontrou_esq==1)
and (encontrou_bai==1) {
    lado_dir=-1;
    lado_cim=-1;
    lado_esq=-1;
    lado_bai=-1;
}
//Agora, aqui calcula se há ou não blocos vizinhos nas verticais (topo e base),
//e faz a mudança das texturas laterais de acordo.
if (bloco_topo==noone) and (bloco_base==noone) {
    lado_topo=28;
    lado_base=28;
}
if (bloco_topo==noone) and (bloco_base!=noone) {
    if (lado_dir!=-1) { lado_dir+=7; }
    if (lado_cim!=-1) { lado_cim+=7; }
    if (lado_esq!=-1) { lado_esq+=7; }
    if (lado_bai!=-1) { lado_bai+=7; }
    lado_topo=28;
    lado_base=-1;
}
if (bloco_topo!=noone) and (bloco_base==noone) {
    if (lado_dir!=-1) { lado_dir+=14; }
    if (lado_cim!=-1) { lado_cim+=14; }
    if (lado_esq!=-1) { lado_esq+=14; }
    if (lado_bai!=-1) { lado_bai+=14; }
    lado_topo=-1;
    lado_base=28;
}
if (bloco_topo!=noone) and (bloco_base!=noone) {
    if (lado_dir!=-1) { lado_dir+=21; }
    if (lado_cim!=-1) { lado_cim+=21; }
    if (lado_esq!=-1) { lado_esq+=21; }
    if (lado_bai!=-1) { lado_bai+=21; }
    lado_topo=-1;
    lado_base=-1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (z==obj_gomez.posicao_zblock-24) {
    mask_index=mask_block;
} else {
    mask_index=mask_none;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código de desenho do bloco:

//Aqui, verifica se a textura é maior que -1 (isto é, ativada), e se a visualização da câmera (direcao_view)
//está em uma posição que a lateral deve ser desenhada!
//No meio, as cores são setadas em branco, cinza claro, cinza e cinza claro,
//para fazer o efeito de shading, como se a luz estivesse vinda de algum lugar.

//Cima:
draw_set_color(c_white);
if (lado_cim&gt;-1) and ((obj_camera.direcao_view&gt;0) and (obj_camera.direcao_view&lt;180)) {
    d3d_draw_wall(x+16,y,z+16,x,y,z,sprite_get_texture(spr_block,lado_cim),1,1);
}

//Topo:
if (lado_topo&gt;-1) { d3d_draw_floor(x,y,z+16,x+16,y+16,z+16,sprite_get_texture(spr_block,lado_topo),1,1); }

//Direita:
draw_set_color(c_ltgray);
if (lado_dir&gt;-1) and (((obj_camera.direcao_view&gt;-90) and (obj_camera.direcao_view&lt;90)) or ((obj_camera.direcao_view&gt;270) and (obj_camera.direcao_view&lt;450))) {
    d3d_draw_wall(x+16,y+16,z+16,x+16,y,z,sprite_get_texture(spr_block,lado_dir),1,1);
}

//Baixo:
draw_set_color(c_gray);
if (lado_bai&gt;-1) and (((obj_camera.direcao_view&gt;180) and (obj_camera.direcao_view&lt;360)) or ((obj_camera.direcao_view&gt;-180) and (obj_camera.direcao_view&lt;0))) {
    d3d_draw_wall(x,y+16,z+16,x+16,y+16,z,sprite_get_texture(spr_block,lado_bai),1,1);
}

//Base:
if (lado_base&gt;-1) { d3d_draw_floor(x,y,z,x+16,y+16,z,sprite_get_texture(spr_block,lado_base),1,1); }

//Esquerda:
draw_set_color(c_ltgray);
if (lado_esq&gt;-1) and ((obj_camera.direcao_view&gt;90) and (obj_camera.direcao_view&lt;270)) {
    d3d_draw_wall(x,y,z+16,x,y+16,z,sprite_get_texture(spr_block,lado_esq),1,1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>8,8</point>
  </PhysicsShapePoints>
</object>
